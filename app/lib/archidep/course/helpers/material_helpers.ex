defmodule ArchiDep.Course.Helpers.MaterialHelpers do
  @moduledoc """
  Helper functions to utilize course material data. This data comes from the
  "archidep.json" file that is generated by the Jekyll build process.
  """

  @course_material_dir Path.expand("../../../../priv/static", __DIR__)
  @course_material_file Path.join(@course_material_dir, "archidep.json")
  @course_material_file_contents File.read!(@course_material_file)
  @course_material_data JSON.decode!(@course_material_file_contents)
  @course_material_file_digest :crypto.hash(
                                 :sha256,
                                 @course_material_file_contents
                               )

  @type course_material_data_source :: {map(), String.t()}

  @spec course_data() :: map()
  def course_data, do: @course_material_data

  @spec course_cheatsheet(String.t()) :: %{title: String.t(), url: String.t()}
  def course_cheatsheet(slug) do
    case Enum.find(course_cheatsheets(), fn cs -> cs["slug"] == slug end) do
      nil ->
        raise "Cheatsheet with slug '#{slug}' not found in '#{@course_material_file}'"

      %{"title" => title, "url" => url} when is_binary(title) and is_binary(url) ->
        %{title: title, url: url}

      _other ->
        raise "Malformed cheatsheet with slug '#{slug}' in '#{@course_material_file}'"
    end
  end

  @spec course_cheatsheets() :: list(map())
  @spec course_cheatsheets(course_material_data_source()) :: list(map())
  def course_cheatsheets(source \\ {@course_material_data, @course_material_file}) do
    {data, file} = source

    case data do
      %{"cheatsheets" => [_cheatsheet | _rest] = cheatsheets} ->
        cheatsheets

      _anything_else ->
        raise "Invalid course material data structure in '#{file}': the 'cheatsheets' key is missing or is not an array"
    end
  end

  @spec course_sections() :: list(map())
  @spec course_sections(course_material_data_source()) :: list(map())
  def course_sections(source \\ {@course_material_data, @course_material_file}) do
    {data, file} = source

    case data do
      %{"sections" => [_section | _rest] = sections} ->
        sections

      _anything_else ->
        raise "Invalid course material data structure in '#{file}': the 'sections' key is missing or is not an array"
    end
  end

  @spec course_document(pos_integer(), String.t()) :: %{title: String.t(), url: String.t()}
  @spec course_document(pos_integer(), String.t(), course_material_data_source()) :: %{
          title: String.t(),
          url: String.t()
        }
  def course_document(num, slug, source \\ {@course_material_data, @course_material_file}) do
    {_data, file} = source

    section_num = div(num, 100) * 100
    section = source |> course_sections() |> Enum.find(&match?(%{"num" => ^section_num}, &1))

    if section == nil do
      raise "Course section #{section_num} not found in '#{file}' while looking for document '#{num}-#{slug}'"
    end

    docs = Map.get(section, "docs")

    if docs == nil or not is_list(docs) do
      raise "Malformed or missing 'docs' key in section #{section_num} in '#{file}' while looking for course document '#{num}-#{slug}'"
    end

    doc =
      Enum.find(
        docs,
        fn doc when is_map(doc) ->
          Map.get(doc, "num") == num and Map.get(doc, "course_slug") == slug
        end
      )

    if doc == nil do
      raise "Course document '#{num}-#{slug}' not found in section #{section_num} in '#{file}'"
    end

    case doc do
      %{"title" => title, "url" => url} when is_binary(title) and is_binary(url) ->
        %{title: title, url: url}

      _other ->
        raise "Malformed course document '#{num}-#{slug}' in section #{section_num} in '#{file}': could not find 'title' and/or 'url' string properties"
    end
  end

  @spec __mix_recompile__?() :: boolean()
  def __mix_recompile__?, do: @course_material_file_digest != course_material_file_digest()

  defp course_material_file_digest,
    do:
      :crypto.hash(
        :sha256,
        File.read!(@course_material_file)
      )
end
